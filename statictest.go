// Package statictest runs static analysis tools as go tests.
//
// It is intended to be used as a substitute for an external build
// step that runs tools such as go vet or golint.
//
// Example Usage
//
//    func TestStaticChecks(t *testing.T) {
//    	basic := statictest.Group(
//    		gofmt.Check{},	// Verify that all files are properly formatted
//    		govet.Shadow,	// go vet
//    		golint.Check{},	// golint
//    		gosimple.Check{},	// gosimple
//    		gostaticcheck.Check{},	// gostaticcheck
//    	)
//
//    	// Ignore some lint errors that we're not interested in.
//    	skipper := statictest.SkipRegexpMatch(
//     		"should omit type InterfaceType from declaration of var Handle",
//    		`settings.go:.*can probably use "var res \[\]byte" instead`)
//
//    	basic = statictest.Skip(basic, skipper)
//
//     	// Verify all files under this package recursively.
//    	if err := skipped.Check("./..."); err != nil {
//    		t.Fatal(err)
//    	}
//    }
package statictest

import (
	"reflect"
	"regexp"
	"strings"
)

// Error implements error and holds a list of failures.
type Error struct {
	Errors []string
}

func (e *Error) Error() string {
	return strings.Join(e.Errors, "\n")
}

// AsError returns nil if Errors is empty or the pointer to Error otherwise.
func (e *Error) AsError() error {
	if e.Errors == nil {
		return nil
	}
	return e
}

// Skipper is used to skip errors. Skip returns true if the error in
// str must be skipped.
type Skipper interface {
	Skip(str string) bool
}

// SkipFunc is an adapter to allow the use of functions as Skippers. If f is a function, SkipFunc(f) is a Skipper that calls f.
type SkipFunc func(str string) bool

// Skip calls s(str)
func (s SkipFunc) Skip(str string) bool { return s(str) }

// StringSkipper implements Skipper and skips an error if Matcher(err, str) == true for
// any of Strings
type StringSkipper struct {
	Strings []string
	Matcher func(err, str string) bool
}

// Skip returns true if Matcher(check, str) == true for any of Strings.
func (s StringSkipper) Skip(check string) bool {
	for _, str := range s.Strings {
		if s.Matcher(check, str) {
			return true
		}
	}
	return false
}

func skip(check string, skippers []Skipper) bool {
	for _, s := range skippers {
		if s.Skip(check) {
			return true
		}
	}
	return false
}

// Skip returns a Checker that executes checkers and filters errors skipped by
// the provided skippers. If checker returns an Error instance the filters are
// applied on Errors.Errors. Each skipper is run in the order provided and a single
// skipper returning true will result in that error being skipped.
func Skip(checker Checker, skippers ...Skipper) Checker {
	return CheckFunc(func(pkg ...string) error {
		switch err := checker.Check(pkg...).(type) {
		case nil:
			return nil
		case *Error:
			var n []string
			for _, e := range err.Errors {
				if !skip(e, skippers) {
					n = append(n, e)
				}
			}
			err.Errors = n
			return err.AsError()
		default:
			if skip(err.Error(), skippers) {
				return nil
			}
			return err
		}
	})
}

// Checker is the interface that wraps the Check method.
//
// Check performs a static check of all files in pkgs, which may be fully
// qualified import paths, relative import paths or paths with the wildcard
// suffix ...
type Checker interface {
	Check(pkgs ...string) error
}

// CheckFunc is a function that implements Checker
type CheckFunc func(pkgs ...string) error

// Check calls c with pkgs
func (c CheckFunc) Check(pkgs ...string) error { return c(pkgs...) }

// Group returns a Checker that applies each of checkers in the order provided.
//
// The error returned is either nil or of type *Errors, containing errors returned
// by each Checker. These are prefixed with the type of the Checker that generated
// the error. For example, an error generated by the govet Checker such as:
//
//    file.go:23: err is unintentionally shadowed.
//
// is converted to:
//
//    govet.Checker: file.go:23: err is unintentionally shadowed.
//
// If an error returned by a checker is of type *Errors, these will be listed
// separately in the final returned error. A checker is not shorted-circuited
// by a previous checker returning an error.
func Group(checkers ...Checker) Checker {
	return CheckFunc(func(pkgs ...string) error {
		errs := &Error{}
		for _, checker := range checkers {
			name := reflect.TypeOf(checker).String()
			switch err := checker.Check(pkgs...).(type) {
			case nil:
				continue
			case *Error:
				for _, e := range err.Errors {
					errs.Errors = append(errs.Errors, name+": "+e)
				}
			default:
				errs.Errors = append(errs.Errors, name+": "+err.Error())
			}
		}
		return errs.AsError()
	})
}

// SkipRegexpMatch returns a Skipper that skips all errors which match
// any of the provided regular expression patterns. SkipRegexpMatch expects
// all patterns to be valid regexps and panics otherwise.
func SkipRegexpMatch(regexps ...string) Skipper {
	return StringSkipper{
		Strings: regexps,
		Matcher: func(errstr, pattern string) bool {
			matched, err := regexp.MatchString(pattern, errstr)
			if err != nil {
				panic(err)
			}
			return matched
		},
	}
}
